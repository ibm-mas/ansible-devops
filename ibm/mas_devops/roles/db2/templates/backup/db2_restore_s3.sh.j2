#!/bin/bash
DB2_BACKUP_VERSION={{ db2_backup_version }}

# Finding the db2 Instance owner
INSTOWNER=`/usr/local/bin/db2greg -dump | grep -ae "I," | grep -v "/das," | awk -F ',' '{print $4}' `

instance=`whoami`
BACKUP_BASE=/mnt/backup

REMOTE_PATH="{{ s3_full_backup_path }}"

### Check if backup files are present in the provided S3 remote path

echo "Verifying backup files in S3 path: ${REMOTE_PATH}"

LIST_OUTPUT=$(db2RemStgManager ALIAS LIST source=${REMOTE_PATH} 2>&1)
rc=$?
if [ $rc -ne 0 ]; then
    echo "Error listing files in S3 path ${REMOTE_PATH}. Return code: $rc"
    exit 1
fi

echo "$LIST_OUTPUT"

TOTAL_FILES=$(echo "$LIST_OUTPUT" | awk -F= '/Total number of files found/ { gsub(/[^0-9]/,"",$2); print $2 }')
if [ "$TOTAL_FILES" -eq 0 ]; then
  echo "No files found in S3 path: ${REMOTE_PATH}"
  exit 1
fi

FILES=$(echo "$LIST_OUTPUT" | awk '/^[0-9]/ { print $2 }')

FOUND_P12=false
FOUND_STH=false
#FOUND_INFO=false
FOUND_BACKUP=false
BACKUP_FILE=""

### Check if Db2 keystore files are present
for FILE in $FILES; do
    if [[ "$FILE" == *.p12 ]]; then
        FOUND_P12=true
    elif [[ "$FILE" == *.sth ]]; then
        FOUND_STH=true
#    elif [[ "$FILE" == *db2-backup-info.yaml ]]; then
#        FOUND_INFO=true
    elif [[ "$FILE" == *.DBPART000.* ]]; then
        FOUND_BACKUP=true
        BACKUP_FILE=$(basename "$FILE")
    fi
done

if [[ "$FOUND_P12" == false ]]; then
  echo "Db2 keystore.p12 file is missing in the backup location: ${REMOTE_PATH}"
  exit 1
fi

if [[ "$FOUND_STH" == false ]]; then
  echo "Db2 keystore.sth file is missing in the backup location: ${REMOTE_PATH}"
  exit 1
fi

#if [[ "$FOUND_INFO" == false ]]; then
#  echo "Db2 db2-backup-info.yaml file is missing in the backup location: ${REMOTE_PATH}"
#  exit 1
#fi

if [[ "$FOUND_BACKUP" == false ]]; then
  echo "Db2 backup files are missing in the backup location: ${REMOTE_PATH}"
  exit 1
fi

echo "Db2 keystore files verified successfully."

### Copy Db2 keystore files from S3 to local path

POD_BACKUP_PATH="/mnt/backup/{{ db2_backup_version }}"
rm -rf ${POD_BACKUP_PATH}
mkdir -p ${POD_BACKUP_PATH}

## Copy Db2 backup files from S3 to local path
echo "Copying Db2 keystore files from S3 to local path: ${POD_BACKUP_PATH}"
db2RemStgManager ALIAS GET source=${REMOTE_PATH}/keystore.p12 target=${POD_BACKUP_PATH}/keystore.p12
db2RemStgManager ALIAS GET source=${REMOTE_PATH}/keystore.sth target=${POD_BACKUP_PATH}/keystore.sth
#db2RemStgManager ALIAS GET source=${REMOTE_PATH}/db2-backup-info.yaml target=${POD_BACKUP_PATH}/db2-backup-info.yaml

for FILE in $FILES; do
    if [[ "$FILE" == *.DBPART000.* ]]; then
        echo "Copying Db2 backup file from S3: ${FILE} to local path: ${POD_BACKUP_PATH}/$(basename "$FILE")"
        db2RemStgManager ALIAS GET source=${REMOTE_PATH}/$(basename "$FILE") target=${POD_BACKUP_PATH}/$(basename "$FILE")
        rc=$?
        if [ $rc -ne 0 ]; then
            echo "Error copying backup file ${FILE} from S3 to local path. Return code: $rc"
            exit 1
        else
            echo "Successfully copied backup file ${FILE} to local path: ${POD_BACKUP_PATH}/$(basename "$FILE")"
        fi
    fi
done

# Extract Db2 keystore master key
# https://www.ibm.com/docs/en/db2/11.5?topic=edr-restoring-encrypted-backup-image-different-system-local-keystore

### Get the database and backup timestamp from the backup file name
# Example backup file name: DBNAME.0.db2inst1.DBPART000.20231015120000.001
DATABASE=$(echo "$BACKUP_FILE" | awk -F. '{print $1}')
echo "Db2 database name extracted from backup file name: ${DATABASE}"

DB2_BACKUP_TIMESTAMP=$(echo "$BACKUP_FILE" | awk -F. '{print $5}')
echo "Db2 backup timestamp extracted: ${DB2_BACKUP_TIMESTAMP}"

MASTER_KEY_LABEL=`gsk8capicmd_64 -cert -list all -db ${POD_BACKUP_PATH}/keystore.p12 -stashed 2>&1 | grep -i $INSTOWNER_$DATABASE | awk '/^#/ { print $2 }'`
if [ -z "$MASTER_KEY_LABEL" ]; then
	echo "MASTER_KEY_LABEL is empty. Cannot proceed with secret key extraction."
    exit 1
else
    ### Check if MASTER_KEY_LABEL exists in the source keystore
    SOURCE_LABELS=$(gsk8capicmd_64 -cert -list all -db /mnt/blumeta0/db2/keystore/keystore.p12 -stashed 2>&1 | awk '/^#/ { print $2 }')
    if ! echo "$SOURCE_LABELS" | grep -q "^${MASTER_KEY_LABEL}$"; then
        echo "MASTER_KEY_LABEL '${MASTER_KEY_LABEL}' not found in source keystore."
        gsk8capicmd_64 -secretkey -extract -db ${POD_BACKUP_PATH}/keystore.p12 -stashed -label ${MASTER_KEY_LABEL} -format ascii -target ${POD_BACKUP_PATH}/master_key_label.kdb
	    echo "MASTER_KEY_LABEL is not empty - Secret key extraction Completed."
        ## Add Master key to target keystore
        result=$(gsk8capicmd_64 -secretkey -add -db /mnt/blumeta0/db2/keystore/keystore.p12 -stashed -label ${MASTER_KEY_LABEL} -file ${POD_BACKUP_PATH}/master_key_label.kdb 2>&1)
        rc=$?
        if [ $rc -ne 0 ]; then
            echo "Error adding master key to target keystore. Return code: $rc"
            exit 1
        fi

        if echo "$result" | grep -q "CTGSK3005W"; then
            echo "ERROR: CTGSK3005W warning detected. Exiting"
            echo "$result"
            exit 1
        fi
    else
        echo "MASTER_KEY_LABEL '${MASTER_KEY_LABEL}' already exists in target keystore. Skipping addition."
    fi
fi


echo "Db2 keystore master key restored successfully."

# Deactivate Db2 in preparation for restore
# https://www.ibm.com/docs/en/db2/11.5?topic=r-restoring-db2-from-online-backup-using-commands

dbRestoreSuccess=true

echo "1. Temporarily disable the built-in HA"
if [ -f /etc/wolverine/config.json ]; then
    wvcli system disable -m "Disable HA before Db2 maintenance"
else
    echo "Wolverine HA not enabled"
fi

echo "2. Connect to the database"
connect_status=$(db2 -v connect to ${DATABASE})
rc=$?
if [ $rc -ne 0 ]; then
    if echo "$connect_status" | grep -q "SQL1032N"; then
        echo "Database ${DATABASE} is not currently active. Proceeding with restore."
    elif echo "$connect_status" | grep -q "SQL1013N"; then
        echo "Database ${DATABASE} does not exist. Proceeding with restore."
    elif echo "$connect_status" | grep -q "SQL30081N"; then
        echo "Network error while connecting to database ${DATABASE}"
        exit 1
    elif echo "$connect_status" | grep -q "SQL1119N"; then
        echo "$connect_status"
        exit 1
    else
        echo "$connect_status. Proceeding with restore."
    fi
fi

echo "3. Disconnect all the applications that are connected to Db2"
db2 -v force application all

echo "4. Terminate the database"
db2 -v terminate

echo "5. Stop the database"
db2stop force

echo "6. Ensure that all Db2 interprocess communications are cleaned for the instance"
ipclean -a

echo "7. Turn off all communications to the database by setting the value of the DB2COMM variable to null"
db2set -null DB2COMM

echo "8. Restart the database in restricted access mode"
db2start admin mode restricted access

echo "waiting for db to start"
sleep 60

echo "9. Restore Db2 from a full backup"
db2 -v restore db ${DATABASE} from ${POD_BACKUP_PATH} taken at ${DB2_BACKUP_TIMESTAMP} into ${DATABASE} logtarget ${POD_BACKUP_PATH} replace existing without prompting
rc=$?
if [ $rc -ne 0 ]; then
    echo "Error restoring database ${DATABASE} from backup. Return code: $rc"
    dbRestoreSuccess=false
fi

echo "10. Check Db2 rollforward status"
db2 -v rollforward db ${DATABASE} query status
rc=$?
if [ $rc -ne 0 ]; then
    echo "Error querying rollforward status for database ${DATABASE}. Return code: $rc"
    dbRestoreSuccess=false
fi

echo "11. Run Db2 rollforward command"
db2 -v "rollforward db ${DATABASE} to end of backup and complete overflow log path ${POD_BACKUP_PATH} noretrieve"
rc=$?
if [ $rc -ne 0 ]; then
    echo "Error during rollforward for database ${DATABASE}. Return code: $rc"
    dbRestoreSuccess=false
fi

echo "12. Stop the database"
db2stop force
rc=$?
if [ $rc -ne 0 ]; then
    echo "Error stopping database ${DATABASE}. Return code: $rc"
    dbRestoreSuccess=false
fi

echo "13. Ensure that all Db2 interprocess communications are cleaned for the instance"
ipclean -a
rc=$?
if [ $rc -ne 0 ]; then
    echo "Error cleaning Db2 interprocess communications. Return code: $rc" | tee
    dbRestoreSuccess=false
fi

echo "14. Reinitialize the Db2 communication manager to accept database connections"
db2set DB2COMM=TCPIP,SSL
rc=$?
if [ $rc -ne 0 ]; then
    echo "Error reinitializing Db2 communication manager. Return code: $rc"
    dbRestoreSuccess=false
fi

echo "15. Restart the database for normal operation"
db2start
rc=$?
if [ $rc -ne 0 ]; then
    echo "Error starting database ${DATABASE}. Return code: $rc"
    dbRestoreSuccess=false
fi

echo "waiting for db to start"
sleep 60

echo "16. Activate the database"
db2 activate db ${DATABASE}
rc=$?
if [ $rc -ne 0 ]; then
    echo "Error activating database ${DATABASE}. Return code: $rc"
    dbRestoreSuccess=false
fi

echo "17. Re-enable the Wolverine high availability monitoring process"
sudo wvcli system enable -m "Enable HA after Db2 maintenance"
rc=$?
if [ $rc -ne 0 ]; then
    echo "Error enabling HA. Return code: $rc"
    dbRestoreSuccess=false
fi

echo "18. Connect to the database"
db2 -v connect to ${DATABASE}
rc=$?
if [ $rc -ne 0 ]; then
    echo "Error connecting to database ${DATABASE}. Return code: $rc"
    dbRestoreSuccess=false
fi

if [ "$dbRestoreSuccess" = false ]; then
    echo "Db2 restore process encountered errors - RestoreFailed"
    exit 1
fi

echo "Db2 database ${DATABASE} restored successfully from S3 backup taken at ${DB2_BACKUP_TIMESTAMP}."
echo "Db2 restore process completed successfully - RestoreSuccess"
exit 0

