---
# Enhanced version with dual CR support (Db2uCluster and Db2uInstance)

# Step 1: Detect which CR type exists
- name: "Detect Db2 CR type (Db2uCluster or Db2uInstance)"
  block:
    - name: Set the retry count
      set_fact:
        retry_count: "{{ 0 if retry_count is undefined else retry_count|int + 1 }}"

    - name: Verify if the Db2 CR exists
      assert:
        that:
          - db2_cr_exists | bool == true
  rescue:
    - fail:
        msg: Ended after {{ db2_cr_detection_retries }}
      when: retry_count|int == db2_cr_detection_retries

    - include_tasks: "{{ role_path }}/../../common_tasks/detect_db2_cr_type.yml"
      register: _detect_result


# Step 2: Validate detection results
- name: "Validate CR detection and state"
  include_tasks: "{{ role_path }}/../../common_tasks/validate_db2_cr.yml"

# Step 4: Lookup and wait for Db2 Pod
- name: "Lookup db2 Pod"
  kubernetes.core.k8s_info:
    kind: Pod
    namespace: "{{ db2_namespace }}"
    label_selectors:
      - type=engine
      - app={{ db2_instance_name }}
    wait: yes
    wait_sleep: 30
    wait_timeout: 300 # 5 mins until we give up waiting for the pod to get into the expected state
    wait_condition:
      type: Ready
      status: "True"
  register: db2_pod

- name: Configure facts
  set_fact:
    db2_pod_name: "{{ db2_pod.resources[0].metadata.name }}"

- name: "Debug information"
  debug:
    msg:
      - "Pod name ............................... {{ db2_pod_name }}"
      - "CR Type ................................ {{ db2_cr_type }}"
      - "CR Status .............................. {{ db2_cr_resource.status.state }}"

# Step 5: Create required directories
- name: "Creating LOGARCHMETH1 folder in {{ db2_pod_name }}"
  shell: |
    oc exec -it -n {{ db2_namespace }} {{ db2_pod_name }} -- su -lc "mkdir -p /mnt/bludata0/db2/archive_log/" db2inst1
  when: db2_cr_type == "Db2uCluster" # Db2uInstance already have archive folder mounted into a PVC
  register: creating_logarchmeth1_folder_output

- fail: msg="Failed to create path for LOGARCHMETH1"
  when:
    - db2_cr_type == "Db2uCluster"
    - creating_logarchmeth1_folder_output.rc != 0

- name: "Creating DB2_OBJECT_STORAGE_LOCAL_STAGING_PATH folder in {{ db2_pod_name }}"
  shell: |
    oc exec -it -n {{ db2_namespace }} {{ db2_pod_name }} -- su -lc "mkdir -p /mnt/backup/staging" db2inst1
  register: creating_stagingpath_folder_output

- fail: msg="Failed to create path for DB2_OBJECT_STORAGE_LOCAL_STAGING_PATH"
  when:
    - creating_stagingpath_folder_output.rc != 0

# Step 6: Validate configuration exists
- name: "Validate configuration version exists"
  assert:
    that:
      - db2_configs is defined
      - db2_config_version in db2_configs.keys()
    fail_msg: |
      Configuration version '{{ db2_config_version }}' not found in db2_configs.
      Available versions: {{ db2_configs.keys() | list }}
    success_msg: "Configuration version {{ db2_config_version }} found"

- name: "Validate CR type configuration exists"
  assert:
    that:
      - db2_cr_type in db2_configs[db2_config_version].keys()
    fail_msg: |
      Configuration for CR type '{{ db2_cr_type }}' not found in version '{{ db2_config_version }}'.
      Available CR types: {{ db2_configs[db2_config_version].keys() | list }}
    success_msg: "Configuration for {{ db2_cr_type }} found"

# Step 7: Update CR with configuration
- name: "Update {{ db2_cr_type }} configuration"
  kubernetes.core.k8s:
    merge_type: merge
    definition:
      apiVersion: "{{ db2_cr_api_version }}"
      kind: "{{ db2_cr_type }}"
      metadata:
        name: "{{ db2_instance_name | lower }}"
        namespace: "{{ db2_namespace }}"
      spec: "{{ db2_configs[db2_config_version][db2_cr_type] | from_yaml }}"
  register: _config_update_result

- name: "Debug configuration update result"
  when: ansible_verbosity >= 1
  debug:
    msg:
      - "Configuration update changed: {{ _config_update_result.changed }}"
      - "CR Type: {{ db2_cr_type }}"
      - "Config Version: {{ db2_config_version }}"

# Step 8: Create ConfigMap to track version
- name: Create k8s configmap for DB2 config version
  kubernetes.core.k8s:
    state: present
    namespace: "{{ db2_namespace }}"
    template: "templates/db2_enforce_config.yaml.j2"
